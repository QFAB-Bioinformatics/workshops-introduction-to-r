[
["index.html", "Introduction to R Abstract", " Introduction to R QFAB Abstract R is a open-sourced software programming language and software environment for statistical computing and graphics. The R language is widely used among statisticians and data analysts for developing statistical workflows for data analysis. R is an implementation of the S programming language combined with lexical scoping semantics inspired by Scheme. R was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand, and is currently developed by the R Development Core Team. Bioconductor is a project to develop innovative software tools for use in computational biology. It is based on the R language. Bioconductor packages provide flexible interactive tools for carrying out a number of different computational tasks. Literate programming and analytical pipeline crafting. R and Bioconductor may not be as fast as dedicated bioinformatics software for computationally intensive processes such as mapping short sequence reads onto the genome, but the flexibility of having raw access to all of the data, methods and structure is empowering. "],
["getting-started.html", "Chapter 1 Getting started", " Chapter 1 Getting started R is a statistical environment and programming language for data analysis and graphical display. The software is open-source, freely available and has been compiled ready for use on Windows, Mac and Linux computers. The Bioconductor framework has a considerable number of packages that have been implemented for the analysis and exploration of metabolomics, proteomics, DNA microarray and Next Generation DNA sequence data. This workshop is intended as an introduction to R that should familiarise you with the concepts that underpin the crafting of workflows in R and some of the key techniques that will aid in the crafting of reusable workflows. Some of the topics we will cover over the course of the day include: Using the RStudio IDE for running a data analysis in R The basics of literate programming for studies using R Loading, creating, modifying and saving basic -omics data objects according to key formats Create graphs and plots of data Understanding how to read and understand someone else’s R-code "],
["how-to-read-this-book.html", "1.1 How to read this book", " 1.1 How to read this book In the shaded dialog boxes with the thick left border are commands that should be typed into your R Console window. This corresponds to input, the output will sometimes follow below with lines preceeded with two hashmarks (##). print(&quot;HELLO WORLD&quot;) ## [1] &quot;HELLO WORLD&quot; Tips, Suggestions and Traps Comments and salient advice are provided in dialogs such as this. We’ll use this format to warn you of traps that you could slip into and to provide some hints. Warnings and Traps Warnings are provided in dialogs such as this. We’ll use this format to warn you of traps that you could slip into and to provide some hints. Time for you to make R work Exercises are the best way to learn. A document can provide an insight to the process but hands-on interaction with R is the only way to learn. In the exercise boxes are some suggested exercises that will apply the knowledge that is being shared. "],
["rstudio-ide.html", "1.2 RStudio IDE", " 1.2 RStudio IDE RStudio is a free and open source integrated development environment (IDE) for R. An IDE is most typically used in software development where a user is presented with a unified environment where code can be edited, documentation can be read and debuggers can be applied to understand what is happening in the code and why it may not be working as expected. In bioinformatics (or computational biology) an IDE provides us with an integrated approach to writing R scripts (or markdown documents), interacting with our data as we implement our script and provides us with an overview of the objects that we have created and their content. RStudio also retains a history of the commands that we have typed, a collection of the figures that we have prepared and provides access to method documentation and package vignettes. We will consider all of these aspects during this workshop. The RStudio IDE is great for the preparation of scripts and reports since the code syntax-highlighting helps you discover typos and errors in your code and even spelling mistakes. RStudio comes in two main flavours: a Desktop version that runs straight off the computer that we are sitting at and a Server version that can be hosted on a slightly more capable computer in a data centre. The server version is sometimes preferable since it is accessed via a web-browser and can be configured with massive memory and disk allocations that might not be practical for a normal laptop. The server version is platform-agnostic (from the user perspective that is; the server itself needs to run Linux) and the Desktop version can be run on Windows, Mac and Linux computers. An example RStudio session running on the Desktop version is shown in Figure 1.1. Figure 1.1: A screenshot of the RStudio session used in the preparation of this course material. The document being prepared is displayed in the top left pane. A figure is shown in the bottom right pane and the loaded environment variables are presented in the top right. Having access to all of these information in a single application is simpler than managing an active R console, a text editor and an image viewer. RStudio integrates very cleanly with a number of best scientific working practices (data sharing, reproducible research and research documentation). RStudio allows for experiments to be performed in projects - this allows you to create a separate workspace for each study that you are performing. Code can be shared between projects easily and Version Control (Subversion and Github) facilitate the sharing of workflows and methods with other researchers. For this course we recommend that you use our server version that has been preconfigured for the software, packages and data that will be used. Open up an RStudio server client and create a project Open a web browser (not Internet Explorer) and connect to the server given to you by the trainer. Use the username and password that we have provided to connect and explore the options available in the top bar. Explore the interface Where is the Files tab? What does it show? Can you see the data folder? Click the data folder to look inside, keep going until you get to some files Click on the Packages tab and look at the list of packages that are installed in R. If you are ahead, scroll down and click on the methods name. This should bring you to the Help tab, see what additional functions you can do using this package. We will talk about what packages are later in the workshop. In the top-right corner of the Help tab is a search text field. Type in “print” and hit enter (if the autofinish starts to pop up click on print). This will show you the print() function and what parameters it accepts. "],
["alternatives-to-rstudio.html", "1.3 Alternatives to RStudio", " 1.3 Alternatives to RStudio RStudio is not the only way to access R. The standard R installation from CRAN (Comprehensive R Archive Network) provides a basic R graphical user interface called the R console. This provides access to the key R functionality and provides interfaces for the preparation of R scripts. The simplest way to access R is perhaps through the command line. With a typical R installation simply typing &quot;R&quot; at the console should load an R session which you can directly interact with, as seen in Figure 1.2. Figure 1.2: R installations typically include a basic R editor and console that provide a basic framework for interacting with the software, preparing R scripts and for the installation and management of packages. This figure shows the R console as installed by default on a Mac computer. "],
["the-r-workspace.html", "1.4 The R workspace", " 1.4 The R workspace The workspace refers to a R working environment and the collection of data objects that have been created by the user. A session refers to an instance of a workspace. In a session you populate your workspace with a collection of objects and functions. A session can be saved, this means that you can save the workspace content so that the next time that you use R you can have all of the information loaded and already available. Session and workspace concepts are best understood within an environment such as RStudio. "],
["literate-programming-and-reports.html", "1.5 Literate programming and Reports", " 1.5 Literate programming and Reports 1.5.1 Literate programming One of the most important things in scientific data analysis is to keep a record of what analyses have been performed on data, why those analyses were chosen, what settings were used, and what the output was. Sometimes it is also necessary to write reports and summarise research data to convince our supervisors, peers and students that we have a solid handle on our science. Not only can R aid in the analysis of data but it can also keep these records and/or write the research report for you at the same time. There are a couple of different ways through which this can be managed, and RStudio provides a number of simple ways to automate the process of running R code, collecting the results of the analysis and preparing a report in HTML or PDF format. Literate programming Try some basic functions in the Console window (the large panel to the left) Type 1 + 1 and hit enter, what is the output and where is it shown? Type print(“HELLO WORLD”) command in the console and hit hit. Try some other functions, e.g.: 3^2 which is three squared or 11%%2 is the modulo function (the remainder left after the first number is divided by the second). Now go to File menu and select New File &gt; R Script and type the same commands in the editor window. highlight line [1] and click on the Run button at the top right of the editor window (or hit [Ctrl]+[Enter] on the keyboard) where is the output shown? highlight all three lines and click on the Run or [Ctrl]+[Enter] Create a New Project that we will use for this course. Under the File menu, select New Project Click on New Directory, then Empty Project Select a name for your project. Generally this should reflect the analysis that you will be performing. Remember, you may want to come back to your projects months or even years in the future. You should now see an .Rproj file in your Files tab, with the name of the project you have just chosen. This file will contain your R session. 1.5.2 KnitR KnitR is a recent framework addition to the RStudio environment and one that we encourage you to use as the basis for this workshop. KnitR is a Markdown language that allows us to combine free text and R code into a single document, and automatically generate documents that include both these and the outputs of the R code. To start, let’s open a new document in RStudio of type RMarkdown. We will create a document and discover how great R markdown is. Create a new knitR document Under the File menu select New File &gt; R Markdown. A window will appear in the top left of your RStudio interface containing your markdown code Click on the question mark character and select Markdown Quick Reference for an guide to knitR formatting. This opens up in the Help tab on the bottom-right window. Change some of the free text that are denoted by the white background. The white free text sections contains subject titles and descriptions that will be included in your output document directly as they are written. Replace line [1] ’Title’ with something more meaningful. Save the file. Click on the Knit HTML button next to the question mark. You should see your rendered report in a new browser. If a popup appears, click on “Try again”. On a new line in the grey blocks, include one of the numerical calculations that you tried before. You can include multiple calculations if you like, but each one should be on a new line. Click on Knit HTML to run your R code and produce an HTML format output of your knitR code The white sections of an R Markdown document is the descriptive part of your report. The grey blocks are referred to as chunks and consists of R code that will be evaluated at run time and the results included in the generated document. Chunks must following the following syntax: The backquote or backtick (`) character is the one immediately to the left of ‘1’ on your keyboard. Using knitR Save your knitR document regularly, to protect your code again the possibility of the software crashing. It will also be saved automatically when you click Knit HTML Create a separate chunk (or code block) for each subsection of the analysis. This makes troubleshooting and bug fixing much simpler. You can run a chunk (or code block) on its own by putting the cursor anywhere in that block and selecting Chunks &gt; Run Current Chunk (top right of knitR window). Or you can run a single line by putting the cursor in that line and clicking the Run button (next to Chunks) -->"],
["data-objects-variables-in-r.html", "Chapter 2 Data objects (variables) in R", " Chapter 2 Data objects (variables) in R As with all other computer languages information needs to be stored in a way that can be recalled, displayed and analysed. A variable name is used to point to a data object in memory (or on disk). A variable name should not start with a number, should not contain spaces and should not contain special characters such as #, %, &amp;. These characters require special handling and often lead to errors that require debugging. "],
["declaring-objects.html", "2.1 Declaring objects", " 2.1 Declaring objects Declaring a object (or variable) is simple in R, we just need to give it a name and the content for that object. This can be done either directly in the console or in a chunk if using knitR. Remember that code entered into the console window will be executed immediately when you press the [Enter] key. But do not expect output for every line you enter, many R commands do not print anything to the screen. Code in the knitR document will only be executed when you run the chunk or click on knit HTML Declare an object Enter the example code below into your RStudio interface. You can type it directly into the console and pressing the [Enter] key after each line or create a new chunk in your knitR document for all lines. Did you get any output after executing line [1]? If you entered above code in the console, click on the Environment tab in the top-right corner window. Do you see the value x listed? If you do not then try again (or select the x &lt;- 42 line in your knitR and click on Run). Try other commands, e.g. y &lt;- 555, do you see a new variable y listed in the Environment tab? x &lt;- 42 # this has set x to the value of 42 x ## [1] 42 print(x) ## [1] 42 Setting object values and viewing object contents Command Description &lt;- This marker is used to set an object’s value. The more standard = operator will also work but they have different levels of precedence. As best practice it is better to use &lt;-. # The hashmark at the start of line is a way to comment your code. This directs R to ignore the rest of the current line. Commenting your good is very good practice and is also used lots to remove commands that you may use in debugging a more complex workflow. print() Is the print function which writes out the value of the object. Simply typing the name of the object will also write out the value contained with in as seen in the examples above: x and print(x) KnitR and Console workspaces It is important to remember that knitR and the Console window operate in different workspaces. This means that if you declare a object in your knitR code and then knit HTML, that object will not be available within the console. In the exercise above, if you created the code as a knitR chunk and then ran knit HTML, try now entering print(x) into the console box. You should get an error Error: object x not found because x was only created within the knitR workspace. Conversely, knit HTML cannot access any objects that were created only in your Console window. Also remember that when you use the Run or Run chunk options, that command will be run and objects created in the Console session, not in the knitR session. "],
["datatypes.html", "2.2 Datatypes", " 2.2 Datatypes In common with many computer languages, every object in R is assigned a type. The primary data types in R are Numeric, Integer, Character, Logical, and Complex (which is used for specialist mathematical applications). The type of an object determines what data can be stored within it and often, what functions can be applied to it. 2.2.1 Numeric Decimal values are called numerics in R. In the previous section we declared an object called x, to which we assigned the value of 42. R recognised this as a number and automatically set the type of x to be numeric. We can test whether an object is a numeric using the is.numeric() function. Or, we can ask directly what type it is using class(). is.numeric(x) ## [1] TRUE class(x) ## [1] &quot;numeric&quot; 2.2.2 Integer Integers are a separate type to numerics and contain whole number values only. Just as we can test whether an object is a numeric, we can also test whether one is an integer: is.integer(x) ## [1] FALSE Strangely, although 42 is indeed an integer, this reports \\(FALSE\\). This is because x has been cast as a numeric and an object can only be of a single type. Indeed even is.integer(42) returns \\(FALSE\\) because R by default assigns any numerical value as type numeric. 2.2.2.1 Typecasting If we want to perform integer functions on x, we can force it from one type to another, in this case using the as.integer() function. This is known as typecasting. The as.integer() function also forces non-whole numbers into integers by rounding them down to the nearest whole number. y &lt;- as.integer(x) is.integer(y) ## [1] TRUE class(y) ## [1] &quot;integer&quot; as.integer(3.1415) ## [1] 3 Writing to objects or the screen In the example above, you will notice that the line y &lt;- as.integer(x) generates no output, while as.integer(3.1415) prints a result to screen. This is because in the first case, the output of as.integer is passed into the object y, while in the second case, no destination is given so by default it prints to screen. This also means that the output from the first command can be accessed and used again later by calling y but the output from the second is lost and cannot be used by future R commands. 2.2.3 Logical Logical datatypes can have one of only two values: TRUE or FALSE. Note, these are case-specific, True or true are not valid logical values. However, the shortcut: T and F will work. TRUE ## [1] TRUE TRUE == TRUE ## [1] TRUE TRUE == FALSE ## [1] FALSE TRUE != FALSE ## [1] TRUE class(FALSE) ## [1] &quot;logical&quot; # Logicals can also be typecast as.integer(TRUE) ## [1] 1 Now try typecasting FALSE to an integer. Next try typecasting in the reverse, that is, converting the digits (1, 0) into TRUE or FALSE. Hint: as.logical() [Optional] If you are ahead, have a look at typecasting other values (e.g. &gt;1 and &lt;0) into logical types. Can you see what is happening? 2.2.4 Character A character object is used to represent strings or text values in R. We convert objects into character values with the as.character() function: h &lt;- &quot;Hello world&quot; class(h) ## [1] &quot;character&quot; as.character(x) ## [1] &quot;42&quot; as.character(FALSE) ## [1] &quot;FALSE&quot; Setting, retrieving and changing data types Enter the code blocks from the sections above (from Numerics through to Character) into your RStudio interface (as before, either into the console or the knitR document), and run them to generate the output. Remember, you can use the Environments tab to keep a track of the objects being created. Note, below all the outputs are shown altogether for readability. If you are running them in console, you will see the output immediately as you hit [Enter]. Experiment with different values so you understand better how the types and typecasting behave. Characters are much more interesting than just storing a piece of text. Try the commands below, which explore a number of fundamental character manipulating functions explained further below. letters &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) paste(letters, collapse=&quot; &quot;) hello &lt;- paste(&quot;Hello&quot;, &quot;World&quot;, sep=&quot;~&quot;) nchar(hello) substr(hello, which(strsplit(hello, &#39;&#39;)[[1]]==&#39;~&#39;)+1, nchar(hello)) gsub(&quot;World&quot;, &quot;R&quot;, hello) grep(&quot;Hello&quot;, hello) grepl(&quot;Stephen&quot;, hello) ## [1] &quot;A B C&quot; ## [1] 11 ## [1] &quot;World&quot; ## [1] &quot;Hello~R&quot; ## [1] 1 ## [1] FALSE Characters, strings and regular expressions Function Description paste() is used to concatenate two or more character objects into a single object. The concatenation can be performed on an object which is itself a list, vector or factor or can be run using individually specified character objects. The sep and collapse arguments are used to specify the delimiter that will be used to link the objects together. nchar() returns an integer value that corresponds to the number of characters contained within the object. substr() is used to prepare a substring from a character object using the start and stop coordinates of the substring to retain. The substr command provided uses slicing of a list object, this will be introduced further in Section [data-structures] strsplit() splits a character object into a list of character objects based on a delimiter. If an empty delimiter argument is provided the individual characters will be returned. gsub() is used to substitute a substring in the given character object with a different (or empty) substring. grep() may be used to identify which elements of a vector contain a given substring character query while grepl() provides a vector of logical responses as to whether the substring exists in each element. "],
["functions.html", "2.3 Functions", " 2.3 Functions Before we move onto data structures in the next section, we will take an aside to look at functions. Functions are a group of commands that perform a specific action. By itself it is not a complete executable program but form part of a larger workflow. Like variables that hold data, functions are also given a name so that they can be reused. They generally follow the input -&gt; process -&gt; output model, that is, they take input, do something with the input and produce output. The output can either be printed to the screen or be returned and assigned to a variable that holds the new data. So far we have already started using some of the in-build functions in R like print(), str(), as.integer() etc. They take the form of output_variable &lt;- function_name(input_variable) where the output_variable is optional. Other than assigning the output of a function to a variable, functions can also be nested within other functions. For example, in the previous exercise, there was the line: letters &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) paste(letters, collapse=&quot; &quot;) Since the object letters is not going to be used anywhere else in our program, we can simply nest the two lines together such that: paste(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) Just like in mathematics, the order of operations (or operator precedence) is the same in R. Operations are evaluated (or executed) from the innermost brackets first. So in the command above, the inner c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) is executed first and the output (which is held temporarily in memory) is then passed to the outer function paste(). With this shortcut, you can reduce the resources that a program takes (not to mention the lines of code) and create very complex nested function calls. Keep an eye out for nested functions throughout the workshop. When new to R and coming across a complex nested function call, the tip is to break it up into sections. Break the functions into smaller pieces starting from the innermost function and assign them to variables first. Execute each line, one at a time and examine the output. Then when you are comfortable with waht each line is doing, put the pieces together again. This will help you understand what each function is doing first before trying to decipher the entire line in one go. Once you become familiar with more functions, reading nested functions will become a breeze! "],
["data-structures.html", "2.4 Data structures", " 2.4 Data structures We do not typically expect to work with atomic objects during an -omics analysis. To make the best use of R we want to use hundreds, thousands and millions of data points. We arrange these in one of a number of different data structures: vectors, lists, matrices and data frames. 2.4.1 Vectors A vector is a group of components of the same type. Elements of a vector can be accessed by their numeric position (referred to as indexing) starting at position 1. They can also be named so that we can access the object component using the namespace. The c() function (for combine) is used to join a number of single values together into a vector. l &lt;- c(1,2,3) is.vector(l) ## [1] TRUE Access the second element of the vector: l[2] ## [1] 2 What happens if we try to mix data types in a vector? str() is a function that describes the structure of an object. mixedVector &lt;- c(animal=&quot;sheep&quot;, meaningOfLife=as.integer(42), pi=3.1415) str(mixedVector) ## Named chr [1:3] &quot;sheep&quot; &quot;42&quot; &quot;3.1415&quot; ## - attr(*, &quot;names&quot;)= chr [1:3] &quot;animal&quot; &quot;meaningOfLife&quot; &quot;pi&quot; c() can be used to combine vectors, not just individual values: c(l, mixedVector) ## animal meaningOfLife ## &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;sheep&quot; &quot;42&quot; ## pi ## &quot;3.1415&quot; Using vectors Enter the code block above into your RStudio interface and review the output. Now enter the next code block below and review the output. Can you determine the difference between mixedVector[2] and mixedVector[[2]]? What would the equivalent command to mixedVector[[2]] be if you were accessing the vector by name? #Access some elements of mixedVector by position or name mixedVector[2] mixedVector[[2]] mixedVector[&#39;animal&#39;] names(mixedVector) Vectors and Collections of data Because elements of a vector must be the same type, when we investigate the content of mixedVector we can observe that the string, integer and numeric have all been cast to character. mixedVector is a named vector, so we can access elements by name as well as position. 2.4.2 Lists Lists are similar to vectors in that the are one-dimensional structures for storing data, and like vectors can be accessed by position or namespace. They differ from vectors in that they can contain multiple different data types. This makes them more flexible for storing data but more limited in the analyses that can be performed on them. Lists are created using the list() command, which has a similar format to c(). mixedList &lt;- list(animal=&quot;sheep&quot;, meaningOfLife=as.integer(42), pi=3.1415) str(mixedList) ## List of 3 ## $ animal : chr &quot;sheep&quot; ## $ meaningOfLife: int 42 ## $ pi : num 3.14 Checking for membership %in% is a way to test the membership of a single element in a list or vector of items. For example, try typing in the command: “sheep” %in% mixedList 2.4.3 Changing Vectors and Lists While a list or vector is useful, their utility is much greater when we can add or remove elements from them, or change the value of existing elements. # Add an item named &#39;pens&#39; with a numeric value of 3 to the list mixedList &lt;- append(mixedList, c(pens=3)) # Now add another item named &#39;papers&#39; with a chr value of &#39;bioinformatics&#39; mixedList &lt;- append(mixedList, c(papers=&quot;bioinformatics&quot;)) # Display just the second element of the list mixedList[2] ## $meaningOfLife ## [1] 42 # Display all but the second element of the list mixedList[-2] ## $animal ## [1] &quot;sheep&quot; ## ## $pi ## [1] 3.1415 ## ## $pens ## [1] 3 ## ## $papers ## [1] &quot;bioinformatics&quot; # Change the value of the pens item mixedList$pens &lt;- 4 # Remove the papers item mixedList$papers &lt;- NULL Using Lists Enter the two mixedList code blocks into RStudio and review the output. Try and retrieve different elements of the list Can you get the second and fourth elements? (Hint: c()) What about everything BUT the second and fourth? [Optional] If you are ahead, now try to getting a range of values, that is get the third to the forth elements. Hint: colon (:) symbol. Now let us imagine that QFAB is actually performing a study on the course participants. To perform subsequent statistical testing we will need to know a little something about each of our consenting subjects, and we are going to build a data structure to store this information. Create three vectors that contain, respectively, the names, sex and age of the research cohort on this course. Let’s have the vectors of type: character for name logical for sex (e.g. have female be TRUE) and integer for age When you have these vectors created, place them all in a single list called subject 2.4.4 Factors Factors are vector objects that contain grouping (classification) information of its components. Functionally they are similar to vectors in that they are a collection of objects of a single type. Factors are best applied when there are a limited number of different values. They are often used when categorical values are used in modelling or presenting data, e.g. phenotypic or study class data, such as diabetic, pre-diabetic, healthy. For the example that we explore in the following exercise, we are going to consider a massive bucket of M&amp;Ms. Assuming that the different colours are randomly mixed with an equal probability we would like to explore a million different sweets. Using Factors Use the code below to create a factorised mandm vector containing 1 million M&amp;Ms of various colours. Note, the output is again grouped together at the end for readability. The table below explains the new functions and what they mean. colours &lt;- c(&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;orange&quot;) mandm &lt;- sample(colours, 1000000, replace=TRUE) object.size(mandm) length(mandm) mandm &lt;- as.factor(mandm) str(mandm) object.size(mandm) table(mandm) head(mandm == &quot;blue&quot;,10) which(mandm == &quot;white&quot;) length(which(mandm == &quot;blue&quot;)) ## 8000280 bytes ## [1] 1000000 ## Factor w/ 5 levels &quot;blue&quot;,&quot;green&quot;,..: 4 1 1 5 5 3 1 1 3 1 ... ## 4000688 bytes ## mandm ## blue green orange red yellow ## 199904 199645 199630 200176 200645 ## [1] FALSE TRUE TRUE FALSE FALSE FALSE TRUE TRUE FALSE TRUE ## integer(0) ## [1] 199904 What is happening here? Function Description sample() is a really useful method that allows you to sample elements from your data collection. The replace variable defined whether a value that is sampled should be replaced following its selection. object.size() describes the amount of memory that an object is using - this can be useful to identify really humungous objects that can be cleaned from your workspace. length() describes the number of elements present in the vector. table() prepares a tabular summary of values and the number of times that they occur - this can be used to summarise data effectively. head() shows only the first n elements of the vector, here we specified show the top 10 elements. which() returns a vector of the positions that means the condition, in this example which of the 1 million mandm’s are ‘white’? Since there are none, this returns an empty vector, represented by interger(0). length(which()) nests the two functions together. It performs the inner which() function first, then passes the result to the length() function. As the names of the function suggest, this is finding out how many elements in mandm are equal to ‘blue’? The real challenge with factors is not creating them or using them but adding novel content to them, at least in terms of new categories. If we find an M&amp;M that is not one of our five original colours, we can’t just change the colour of that entry in our vector, we need to specifically add that colour to our factor list first. As a result, factors are suited more for immutable or static content. Other data containers provide simpler mechanisms for data manipulation. Adding factor values Follow the code below to try to change the colour of the first M&amp;M to white. The comments explain what each line is doing. You may find it best entering these commands directly in the console rather than the knitR document at first, so you can see what is happening at each stage. Add another colour option and change one or more of the vector values to that new colour. # First, just try to change the first element to white mandm[1] &lt;- &quot;white&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;white&quot;): invalid factor level, ## NA generated # Check the factor values - have we successfully added white? levels(mandm) # Now explicitly add white as a factor value levels(mandm) &lt;- c(levels(mandm), &quot;white&quot;) # Try again to change the colour of the first M&amp;M mandm[1] &lt;- &quot;white&quot; # And check the factor values again levels(mandm) table(mandm) 2.4.5 Matrices A matrix is a collection of data elements arranged in a two-dimensional rectangular layout, effectively a table. Similar to the vector a matrix can contain only a single type of data. It is often easiest to create a matrix from a vector of data. The next exercise will show you how to do this, follow the code below to generate a variety of matrices. R cannot guess the dimension of the data so you should specify either the number of rows (nrow) or columns (ncol) that the final data should have. Creating a matrix Enter the code below to generate a variety of matrices. Hint: Use the Help tab to search for matrix to find out more about the function and what the nrow and byrow options are doing. Rather than printing the output directly to screen, store the matrix in an object e.g. testMatrix. Note, this time the output follows immediately after each command, so that you can compare with what you get. matrix(c(1,2,3,4,5,6,7,8,9,10,11,12)) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 matrix(c(1,2,3,4,5,6,7,8,9,10,11,12), nrow=4) ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 matrix(c(1,2,3,4,5,6,7,8,9,10,11,12), nrow=4, byrow=TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 matrix(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;),nrow=4, byrow=TRUE) ## [,1] [,2] [,3] ## [1,] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## [2,] &quot;D&quot; &quot;E&quot; &quot;F&quot; ## [3,] &quot;G&quot; &quot;H&quot; &quot;I&quot; ## [4,] &quot;J&quot; &quot;K&quot; &quot;L&quot; Instead of typing out the letters above, look at the built in variable LETTERS in R. You can simply type this in the console and see what is returned. Use class(LETTERS) to find out the datatype. Also try the following command: LETTERS[1:8]. You can also specify a list of sequence numbers in a similar manner, try typing 1:10 on the console and see what you get. Assign this to a object named range. 2.4.6 Data frame The data frame is to a matrix what a list is to a vector. Like a matrix it is a two dimensional table for storing data and is made up of equal length rows and columns, but like a list, the columns can contain data of different data types. Although within a column the data must all be of the same type. Creating a data frame Follow the code below to start exploring data frames. The comments explain what is happening at each stage. The first step tries creating a data frame using the same format as creating a matrix. This doesn’t work though, see if you can work out what is actually happening here. # Try creating a data frame using the same terminology as a matrix data.frame(c(LETTERS[1:12]),nrow=4, byrow=TRUE) # Now build a data frame from a temporary matrix as.data.frame(matrix(c(LETTERS[1:12]),nrow=4, byrow=TRUE)) exampleDf &lt;- as.data.frame(matrix(c(LETTERS[1:12]),nrow=4, byrow=TRUE)) # It&#39;s often useful to name the columns and rows of a data frame (or matrix) colnames(exampleDf) &lt;- c(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;) rownames(exampleDf) # What is the size and structure of our data frame dim(exampleDf) # Dimensions ncol(exampleDf) # Number of columns nrow(exampleDf) # Number of rows str(exampleDf) # Structure # Retrieve a &#39;data slice&#39; from the data frame # First, get the contents of the first column exampleDf[,1] # Then the contents of the first row exampleDf[1,] # Finally, add a fourth column of a different type to the data frame exampleDf[,4] &lt;- c(1,2,3,4) exampleDf class(exampleDf[,3]) class(exampleDf[,4]) In the previous exercise we created a list that described the subjects within this group. A data.frame would be more convenient to use. Convert the earlier list of vectors into a data frame. If you gave names to the elements of your list earlier, the columns of your data frame should have inherited these names. Check that this is the case, and try naming the columns if not. "],
["finding-describing-and-removing-objects.html", "2.5 Finding, describing and removing objects", " 2.5 Finding, describing and removing objects In the previous data types section we have created a couple of lists, integers, numerics and a data.frame. This is the beginning of a data analysis workflow. While you are typing at your keyboard it is simple to become distracted and to forget the name of the object that you created, or to create many temporary object that you no longer need. Tidying up objects Use the ls() function to list all the objects in your workspace. Use ls() to get rid of an object or objects that you no longer want. To remove multiple objects, just enter the names of all those objects separated by commas Delete everything from your workspace using rm(list=ls()). Review your history (all the commands you have entered into the console in this session) using the RStudio History tab (top right window). ls() rm(h) rm(x, y) rm(list=ls()) history() "],
["best-practise-and-object-naming-conventions.html", "2.6 Best practise and object naming conventions", " 2.6 Best practise and object naming conventions Some quick best practice tips: Best practice suggests that you should not assign meaningless names to variables; give an object a succinct but meaningful name that will be of value to understand which information you have saved. df may be an obvious name for a data.frame, but phenotypeDf or phenotype.df may be more memorable later on in your analysis. you can use camelCase (or camelNotation), underscore (_) or fullstop (.) for object names in R. You can create thousands of objects in your R workspace but are they all necessary? It is worthwhile performing housekeeping on your data collection if you are creating many objects. If you have many objects in your R workspace then you may not be using the most ideal objects to store your data. data.frame and list objects can better structure your data. RStudio allows you to remove all objects from your workspace by using the Clear button in the Environment tab as an alternative to the command: rm(list=ls()). (You can follow this with the gc() function for garbage collection to further ensure that memory has been freed up.) -->"],
["going-further-with-r.html", "Chapter 3 Going further with R", " Chapter 3 Going further with R This section is a quick glance at the other features in R that will help you in your future data analysis. We will quickly look at: Documentation with R Extending R with packages - what are packages and how to install and load packages in R Vignettes that come with R packages including citing packages SessionInfo information to reproduce your data analysis, and Other ways to run R "],
["documentation.html", "3.1 Documentation", " 3.1 Documentation As you may now appreciate, there is a massive amount of information tied to R. There are functions already implemented for most of the typical data transformations that you may wish to perform. One of hardest challenges with R is finding the method that does what you need. It’s out there! Function Description ? is used to find out information about a specific function. E.g. ?t.test will give you information about how to use the t.test function in R. apropos() will return a vector of all the objects or functions with names containing the specified search string. E.g. apropos(&quot;test&quot;) will find around 50 different statistical test functions, while apropos(&quot;mixed&quot;) will find mixedList and mixedVector from earlier (or at least it would if we hadn’t just deleted all our objects!) help.search() searches the help documentation for entries matching the search string. Items will match if the search term is included in the function description or keywords, not just the name as is the case for apropos. ?t.test apropos(&quot;test&quot;) help.search(&quot;topic&quot;) "],
["extending-r-with-packages.html", "3.2 Extending R with packages", " 3.2 Extending R with packages One of the reason that R has such a following in the statistical and biological fields is the range of available packages that can be used to extend the utility of the software. Packages are collections of functions, data, and compiled code written in R and other languages that are encapsulated and distributed in the package format. The directory where packages are stored is called the library. R comes with a standard set of packages. Others are available for download and installation from repositories that include CRAN, Bioconductor and R-forge. To use a package, you must first install it, and then load it into your session using either the require or library functions. Because of the configuration of the training server we are using today, it is not possible to install packages to it yourself, but the code below outlines the process involved # Look to see which packages are already installed library() # To install one that is not there, use install.packages # N.B. This will not work on the training server install.packages(&quot;VennDiagram&quot;) # Once it&#39;s installed, we need to load it require(&quot;VennDiagram&quot;) # or library(&quot;VennDiagram&quot;) # library() shows the installed packages. search() shows which of those are loaded. search() # If you no longer need a package, then you may want to unload it with detach() # You need to specify &quot;package:&quot; before the name, as per the listing from search() detach(&quot;package:VennDiagram&quot;) Using packages Use library() and search() to see what packages are available on the training server and loaded into your workspace. Load the limma library using either require() or library(). Use search() again to check it has loaded correctly. "],
["vignettes.html", "3.3 Vignettes", " 3.3 Vignettes Just now, we explored some of the help functions built into R. As well as this builtin help, most R packages also come with their own, often extensive, documentation. This is normally in the form of a vignette, a document that provides a task-oriented description of package functionality. Vignettes contain executable examples and are intended to be used interactively. You can also download the vignette for a package that isn’t installed on your system by visiting the Bioconductor project webpages, or via an internet search. Using vignettes The vignette() command provides access to vignettes for installed packages. Run vignette() at the console to list all the vignettes available. Notice that a package can, but does not always, have a vignette with the package name - for example the annotate package has an annotate vignette, but BiocParallel only has the IntroductionToBiocParallel vignette Type vignette(“biomaRt”) to open the vignette for the biomaRt package, which links to the Biomart gene annotation database. Some vignettes have non-unique names - for example, several packages have an intro vignette. Try vignette(“intro”) To get the limma package vignette, use the command vignette(“intro”, package = “limma”) 3.3.1 Citations The R core development team and the very active community of package authors have invested a lot of time and effort in creating R as it is today. Please give credit where credit is due and cite R and R packages when you use them for data analysis. citation(&quot;VennDiagram&quot;) citation(&quot;limma&quot;) "],
["sessioninfo.html", "3.4 SessionInfo", " 3.4 SessionInfo Congratulations - you have now conquered the basics of R and you are ready to start breaking things! One of the most useful aspects of R is the rich ecosystem of supplementary packagess that can aid, facilitate and empower your research. The Bioconductor framework contains hundreds of packages of methods of relevance to biologists working with biological data (population genetics, SNPs, NGS reads, microarrays, massspectrometry etc). As we discovered in the Vignette section, there are well documented tutorials and guides that will work us through the application of fabulous methods and workflows. You will come across some unexpected ’error’ messages. R packages are written by people like the QFAB bioinformaticians. Well intentioned, but busy. Code is crafted lovingly and tested in the scenarios that are implicit in our daily development. You are likely to be running R on a different computer with combinations of installed packages that are subtly different to those that we wrote the software with. If you identify a ”bug” in that the package gives a wrong result, fails with a hairy error message or misbehaves it is worthwhile to let the developer know that you are having a problem. Reproducibility of the error is critical - we would like to know which version of R is being used and all of the packages that are loaded in memory so that the developer can agree that yes, there is a problem and can help in the resolution. It is trivial to report the data on the R environment that you are working in - the SessionInfo function reports installed packages and their versions. require(limma) ## Loading required package: limma ## Warning in library(package, lib.loc = lib.loc, character.only = TRUE, ## logical.return = TRUE, : there is no package called &#39;limma&#39; sessionInfo() ## R version 3.3.0 (2016-05-03) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 10240) ## ## locale: ## [1] LC_COLLATE=English_Australia.1252 LC_CTYPE=English_Australia.1252 ## [3] LC_MONETARY=English_Australia.1252 LC_NUMERIC=C ## [5] LC_TIME=English_Australia.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] Rcpp_0.12.5 bookdown_0.1.5 digest_0.6.9 ## [4] assertthat_0.1 mime_0.4 R6_2.1.3 ## [7] xtable_1.8-2 formatR_1.4 magrittr_1.5 ## [10] evaluate_0.9 stringi_1.1.1 rstudioapi_0.6 ## [13] miniUI_0.1.1 rmarkdown_1.0.9008 tools_3.3.0 ## [16] stringr_1.0.0 shiny_0.13.2 httpuv_1.3.3 ## [19] yaml_2.1.13 htmltools_0.3.5 knitr_1.14 ## [22] tibble_1.1 "],
["other-ways-of-running-r.html", "3.5 Other ways of running R", " 3.5 Other ways of running R Today we are using RStudio, but R can be run in a number of different ways; for example, you could embed some R functionality in a computer program written in Python or Java. As discussed in section 1.3 both R and RStudio provide an interactive environment where you are prompted to enter a single command at the time. In this training course we are providing you with snippets of information that could be used within a data analysis workflow. These are intended to be run interactively. In a bioinformatics laboratory the scientists who use R craft a mixture of packages and workflow scripts into analytical pipelines. R may be even be called by other software environments. Bioinformaticians will typically use the R console for refining, tuning and modifying existing scripts that they have written. The workflow is run through master scripts. In this section we will look at a simple R script that will create a table of information and write it out to file. We will be having a more complete look at the process of writing data to file in a later section (Section 4.2). The advantage of running R scripts as a batch analysis is that larger and more complex analyses (such as the mapping of short DNA sequence reads) can be run overnight and each of the commands will run successively as prior commands complete. 3.5.1 Preparing an R script An R script is a container for multiple R commands. It is intended to be run largely hands-off. The RStudio software provides us with a very convenient way to create an R script - in the file dialog there is the option to create file and an R Script is a primary file type. R scripts typically have the extension .R. The file is a plain text file and needs to know the packages that should be loaded, the objects that should be set and the working environment where we should be working. 3.5.2 Running an R script R CMD BATCH [options] my_script.R [outfile] R.exe&quot; CMD BATCH --vanilla --slave &quot;c:\\my projects\\my_script.R&quot; -->"],
["importing-and-exporting-data-from-r.html", "Chapter 4 Importing and exporting data from R", " Chapter 4 Importing and exporting data from R It is likely that you will not always be able to complete your R analysis in a single sitting. Rather than having to recreate all your objects each time, there are various ways that you can save data for reuse. This section covers how to save your session data, importing and exporting data. "],
["saving-session-data.html", "4.1 Saving session data", " 4.1 Saving session data If you started a new Project for your work, at the end of the day you can select File &gt; Close Project. This will save all of your objects, your history, your open files and a range of other information. When you then re-open R, you can double click on the project file (which will have the suffix .Rproj) to continue where you left off. As well as saving your entire project, you can save just specified objects, using the save() command, for later reloading using load(). Load and save objects Follow the code below to create a new object, save that object to a file, delete that object from the active workspace, and then restore it from the file. # Create a new object hw &lt;- &quot;HelloWorld&quot; # Save that object to a file called &quot;myfile.RData&quot; save(hw,file=&quot;myfile.RData&quot;) # Delete hw from the workspace remove(hw) # And confirm that it&#39;s gone print(hw) # Reload the data from the file load(&quot;myfile.RData&quot;) print(hw) # You can save multiple objects testVector &lt;- c(1,2,3) save(hw, testVector, file = &quot;myfile.RData&quot;) remove(hw, testVector) load(&quot;myfile.RData&quot;) print(hw) print(testVector) "],
["reading-and-writing-tabular-data.html", "4.2 Reading and writing tabular data", " 4.2 Reading and writing tabular data Data is most commonly shared in tabular formats (Excel presents data in a tabular format). These are most-often text files that contain columns of data separated with comma, tab or other field-delimiters. In R there are some simple methods for quickly reading in massive amounts of data. For the next few steps in this course we are going to explore a public dataset of human tissue gene expression data that was originally produced by Novartis. The dataset is known as the Novartis GeneAtlas data (now called BioGPS) and can be found in the GEO database under accession GSE1133 (http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE1133). We will look at some Affymetrix gene expression data from the study. These data have been prepared from microarray hybridisations using the Affymetrix Human Genome U133A Array. The data is in the file GSE1133-GPL96_series_matrix.txt. # read data from the training server data.path &lt;- &quot;/data/Intro_to_R&quot; # Of course, you will need a different path if the data is on your local P.C. # e.g. data.path &lt;- &quot;C:/Intro_to_R/Data&quot; # Create an object pointing to the file location. gene.atlas.file &lt;- file.path(data.path, &quot;GSE1133-GPL96_series_matrix.txt&quot;) # Then look at the start and finish of that file head(readLines(gene.atlas.file)) tail(readLines(gene.atlas.file)) What is happening here? Function Description readLines() reads each line from a target file into a vector. See also read.table, read.csv functions. file.path() DOES NOT read in the contents of a file. It just point to the location of a files on your system. You need to use readLines, read.table or similar to access the contents of that file. Using the head and tail commands helps us understand the nature of the file. It seems that the ! prefix indicates metadata rather than data. Beware of printing large objects with RStudio Server, you can freeze your session. Judiciously use methods to limit the output: read into a variable first limit the output use head() / tail() functions We have started to explore the contents of the expression data file using the code above, but at the moment have not imported it into an object in R. Before we get to that stage, we will first load the annotation data associated with this expression dataset. Reading in tabular data If you have not already done so, use the previous code block to set up your data.path and take an initial look at the expression data in the file gene.atlas.file file. Follow the annotated code below to use read.table() to import the annotation data, or metadata, for this experiment # As before, define the location of the file annotation.file &lt;- file.path(data.path,&quot;GSK_RNA.sdrf&quot;) # Look at the first six lines of the data # sep = &quot;\\t&quot; means that the data is tab-separated head(read.table(annotation.file, sep=&quot;\\t&quot;)) # The last command included the header as the first line of data. # Specify (header = TRUE) that the first line contains header information head(read.table(annotation.file, sep=&quot;\\t&quot;, header=TRUE)) # Use read.table to import the data into an object expressionMetadata &lt;- read.table(annotation.file, sep=&quot;\\t&quot;, header=TRUE) # Find out some information about the structure and contents of that new object tail(expressionMetadata) dim(expressionMetadata) colnames(expressionMetadata) str(expressionMetadata$Material.Type) # By default, read.table imports text fields as factors. That&#39;s probably # not what we want, so disable it with stringsAsFactors=FALSE expressionMetadata &lt;- read.table(annotation.file, sep=&quot;\\t&quot;, header=TRUE, stringsAsFactors=FALSE) str(expressionMetadata$Material.Type) Note that the lines starting with the default comment symbol (#) have been omitted from the import. Read the expression data into an object called gene.atlas In the last couple of sections we have used readLines() to look at the content of a file and we have used read.table() to read some experimental metadata into a data frame. Your challenge is now to import the “GSE1133-GPL96_series_matrix.txt” data into a data frame called gene.atlas. Hints: * Use the read.table documentation to discover the nuances of the function. * This import is not as simple as the annotation file. You will need to make some inferences about the structure of the file (Hint: use head() and tail() and look at some of the options for read.table() in the Help.) * Make sure that the proper column names are included in the data frame. "],
["scan.html", "4.3 Scan", " 4.3 Scan scan is a primitive method that can be used to import data from a variety of sources. In most instances it would be preferable to read data from file using read.table or readLines. scan is however magnificent for reading in data from the standard input or from other software streams. As a quick demonstration we can read in data as you type it: scan(what=numeric()) "],
["reading-from-a-web-connection.html", "4.4 Reading from a web connection", " 4.4 Reading from a web connection Most of the time we will be reading information into R that is stored on our local filesystem, but R can also import data directly from the web. The read.table() and readLines() functions are happy to read in from a web socket. This is great but requires that the data be present on a web-page to download. The RCurl package provides a much more flexible approach to accessing data that is on the web and is worth reviewing if you wish to scrape a web-accessible database in a more automated fashion. Of greatest interest however is the ability to download pre-structured biological data from the web. This can be managed using packages such as bioMart and GEOquery. NOTE: you might need to set up your http / ftp proxy using the Sys.setenv function web.data &lt;- readLines(&quot;http://data.princeton.edu/wws509/datasets/effort.dat&quot;) # ho-hum - we can read in the data but it is neither up-to-date or biorelevant... # we can pull in the GeneAtlas data straight from GEO library(GEOquery) geo.gene.atlas &lt;- getGEO(myGSE, destdir=&quot;.&quot;) # or load the GEO data previously downloaded in text format library(GEOquery) gene.atlas.gpl96 &lt;- getGEO(filename=file.path( data.path,&quot;GSE1133-GPL96_series_matrix.txt&quot;)) class(gene.atlas.gpl96) str(gene.atlas.gpl96) colnames(pData(gene.atlas.gpl96)) # w00t - we have an ExpressionSet head(exprs(gene.atlas.gpl96)) gene.atlas &lt;- exprs(gene.atlas.gpl96) What is happening here? This code is a little scarier than some of the code that we have run thus far. getGEO() imports data from the Gene Expression Omnibus (GEO) database. Since there are three different platforms used within the study we need to select for our Affymetrix platform of interest - we select the appropriate element from the list. pData is a method that selects the phenotype data from the header of the GEO file (this is contained within the ! flagged fields from our earlier data import). This phenotypic data is rather crucial to the analysis/ The data has been imported as an ExpressionSet rather than as e.g. a data.frame. The ExpressionSet is a crucial data-type that is used in most gene expression data workflows. The ExpressionSet contains the phenotypic data, the expression signal intensities and other data that could be of value to the data analysis. The expression data can be extracted using the exprs() function. -->"],
["transforming-and-summarising-data-in-r.html", "Chapter 5 Transforming and summarising data in R", " Chapter 5 Transforming and summarising data in R So far we have looked at creating data, importing data and we have applied a couple of functions so that we can view the contents of the data. Now is where things can start getting more interesting. Once you have loaded or created your data, you want to start processing and making sense of your data. In this section we cover how to write your own user-defined functions (Section 5.1), which as the name suggests are functions you write yourself instead of using the built-in functions. Sections 5.2 and 5.3 will cover methods for looping through your data and we finish this chapter off with Basic data analysis methods in Section 5.4. "],
["user-defined-functions.html", "5.1 User defined functions", " 5.1 User defined functions While there are hundreds of packages that can do everything that you need in R, it is often quicker to write a function to do something specific than it is to find someone else’s function. For purposes of scientific reproducibility, for automation and for clean-code wrapping chunks of code into functions is a must! Crafting a function is pretty simple. We use the function() command, and provide it with a name for our new function and some logic for that function to perform. # Create a function called testFunction testFunction &lt;- function(a, b=2, add=TRUE) { if (add) { # If the logical add is TRUE, then carry out this section a + b # Add a and b and return the result } else { # or if add is FALSE, then do this instead a - b # Subtract b from a and return that result } } # Test what we get with some different input options testFunction(1) testFunction(2, 4) testFunction(2, add=FALSE, b=4) # Create a second function to report absolute magnitude, # calculated as the square root of the square of the input testFunction2 &lt;- function(x) { return(sqrt(x^2)) } testFunction2(-123.2) What is happening here? In the first example abvoe, we create a function called testFunction. This takes the following three arguments: required numerical value named a, an optional numerical value named b and an optional logical value named add. Arguments b and add are given default values of 2 and TRUE respectively by the equal (=) sign in the function declaration. THese defaults valuese are used in the logic of the function if no other values are provided when the function is called. The second example named testFunction2, takes a single required numerical value only and returns the absolute magnitude of that value. Functions can contain any data-type as input; you can have a mixture of default values and required values. Creating and using functions Use the code above to create and experiment with the two example functions named testFunction and testFunction2. Create a new function based on the testFunction code that can be used to multiply or divide two numbers. Using our character manipulation commands from Section 2.2.4 Character, to create a function that accepts two inputs: (i) a character string and (ii) an integer. This function will return the letter at that number position in the string. How about a function that takes a row count and a column count and creates a matrix of those dimensions filled with either numbers or letters (as defined by a third input parameter). Functions and Packages Keep things in functions simple and structured. Use some form of indentation to keep your code readable so that you can follow what is happening. Have a look at the R coding conventions (and links contained within) at http://journal.rproject.org/archive/2012-2/RJournal_2012-2_Baaaath.pdf. An explicit return is not required in a function. By default a function will return the last executed command. However, it is worthwhile to include a return statement if you have a complicated function that has multiple endpoints and logical decisions. This also makes debugging easier. You can also use return() to create and return complex data structures If you think that writing a function is great, the next step will be to write whole packages that automate, streamline and focus your research. This is not difficult but unfortunately does not fit in the scope of this workshop. "],
["for-loops-while-loops-and-vectorisation.html", "5.2 For loops, While loops and Vectorisation", " 5.2 For loops, While loops and Vectorisation for loops are controversial in R. They are slow and inefficient and due to the way that R has been crafted (the concept of vectorisation) there are typically faster and more efficient ways to process data. This is an introductory course and we don’t have time to go into the depth required for the various apply and dplyr methods that will guarantee amazing performance. The for loop is suitable for getting proof-of-concept workflows running! To create a loop, we need to set a looping condition. There are two types in R: a for() loop will run on each element of the input object, and a while() loop repeats until an exit condition is reached. Note, you must ensure that you update the exit condition so it eventually becomes true, otherwise you will get an infinite looping error where you code never exists until it uses up all available resources (usually the memory). We also need to wrap that loop in braces ({ and }) to define the start and end of the code block to be iterated. # a simple for loop along a sequence of numbers generated by seq() for (i in seq(10)) { print(i) } # You can also loop through a vector, or even a matrix for (colour in c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)) { print(colour) } # A while loop is similar in structure # Start with a value of i = 1 i &lt;- 1 # Loop while i is less than or equal to 100 while (i &lt;= 100) { print(i); # Remember to increment i each loop, otherwise it will loop forever i&lt;&lt;-i+1; } Advantages of vectorisation Why don’t we use loops often in R? Because vectorisation is a fundamental approach in R. This means that a function can be applied to every element of a vector or matrix without having to explicitly loop through the whole object. # vectorisation means that for loops are not quite as essential in R # Generate the square root for every number from 1 to 100 sqrt(seq(100)) # Create a temporary vector, and multiply every element in it by pi c(1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1) * pi # Perform a log transformation on every element of our expression # dataset and print out the first few lines head(log10(gene.atlas)) Loops and Vectorisation Experiment with the loops and vectorisation examples above Try creating a loop that counts in 2 down from 100 to 0 Create a vector containing the numbers from 1 to 20. Use a vector calculation to create a second vector containing the squares of those numbers Performing a vectorised function on a vector or matrix does not change the contents of that object. To perform an in-place calculation, you need to explicitly overwrite the object with the output of the function, e.g. gene.atlas &lt;- log10(gene.atlas). Examine the values in gene.atlas after you have performed the log10() function as in the last line of the code block above. Now try explicility overwriting the gene.atlas object with the log10() values and examine the object again. [optional] If you are ahead, can you get the original gene.atlas values back? Hint: logb(x)=y and by = x Going Loopy Try to avoid for loops in production code, use them for testing ideas and exploring data. R objects are often vectors and can be analysed in bulk using normal mathematical and statistical transformations. This applies for the vectorised data in data.frames and matrices. factors cannot be used quite as easily in such analyses, so beware. seq() generates a regular sequence of numbers and is useful in testing. "],
["apply-lapply.html", "5.3 Apply, Lapply", " 5.3 Apply, Lapply In the previous section we considered the simplicity with which we could perform simple transformations on vectorised data. In these examples a discrete transformation was applied to each value. If we consider our chunk of gene expression data in the gene.atlas object, we can imagine a number of simple transformations that we might wish to perform such as log2 transformations. There are more cases when we might wish to perform an analysis by row or column within the data. While this could be managed using a for loop to iterate over the data there are a number of simpler ways to access the data. One way to do this is with apply(). apply() takes at least three arguments - the matrix of input data, the MARGIN (whether to perform the calculation by row or column) and the function itself. This function can be one that is predefined in R (such as mean or sd in the exercise below) or one you have created yourself as per the function section above. In the latter case remember that the function should expect a vector as input and return a single value (e.g. it receives a vector of numbers and returns their mean). Use the code below to find the standard deviation and the mean of each of the first few rows of the gene.atlas object using apply apply(head(gene.atlas), MARGIN=1, sd) apply(head(gene.atlas), MARGIN=2, mean) apply apply is a crucial method for exploring data within the rows and columns of a data frame or matrix. The apply method needs to know which margin of the data the function should be applied to - this is specified with the MARGIN variable which should be 1 for rows and 2 for columns. lapply is similar to apply but it returns results on a list rather than a matrix This is also the dplyr package, which is even more powerful but is beyond the scope fo this workshop. See https://cran.r-project.org/web/packages/dplyr/dplyr.pdf "],
["basic-data-analysis-methods.html", "5.4 Basic data analysis methods", " 5.4 Basic data analysis methods We have already been introduced to the mean() and sd() functions and as you might expect R provides many other numerical summary functions. These include: Function Description sum() total sum of a numeric vector or matrix mean() mean value of a numeric vector or matrix sd() standard deviation, if your object has missing values (NA) then see the na.rm option min()/max() minimum/maximum value in your object, also see the na.rm option range() range (min and max) for a numeric vector or matrix sqrt() is the square root of a numeric object. Can be applied to a vector or matrix, in which case it will return the results in vector or matrix form sample() select a specified number of items at random from a vector. Can be used without replacement, where an item can only be selected once (for example, to select five test subjects out of a pool of twenty) or with replacement, where items can be selected multiple times (as we did for the M&amp;Ms exercise) duplicated() provides a vector of logicals indicating which elements of a vector have already been seen in that vector. In other words, the first time a value is seen it will return FALSE, and then if it occurs again it will return TRUE) unique() Provides a non-redundant list of all values in a vector; any duplicated values will be output only the first time they are seen Data summary functions Follow the commented code below to explore some of the above functions. # Take the 101st line of the gene.atlas data as our test dataset x &lt;- as.numeric(gene.atlas[101,]) # Find various statistical summaries of that test data sum(x); mean(x); sd(x); sqrt(x) min(x); max(x); range(x) # randomly pick 50 numbers between 1 and 100. x &lt;- sample.int(100, 50, replace=TRUE) # replace = TRUE, so some numbers may have been picked more than once duplicated(x) # This isn&#39;t very helpful, since it just gives us a list of TRUE and FALSE # By taking a vector &#39;slice&#39;, we can get the values of those TRUE items x[duplicated(x)] # show the unique(or rather, non-redundant) numbers unique(x) # Show the number of times that any value is present in the data # In this case, we&#39;re sampling 500 integers between 1 and 10 table(sample.int(10, 500, replace=TRUE)) Analytical methods For this exercise, the numeric data taken from the gene.atlas data frame has been cast into a vector using the as.numeric() function. Slicing a data frame will usually return a data frame and some methods will only function with a vector. -->"],
["data-presentation-and-reporting.html", "Chapter 6 Data presentation and reporting", " Chapter 6 Data presentation and reporting In the previous sections we have looked at a number of ways to import data, access data, summarise data. We should now consider how we best present data in a graphical way. R is endowed with a number of native and add-on packages that facilitate the preparation of figures, diagrams and graphs. In this section we will explore plots prepared using mainly the ggplot2 package. ggplot2 is not the simplest library to use to prepare plots at the start, but it is the most configurable and powerful. Where possible we will also look at the simpler native approach to prepare a graph or chart. To begin working with ggplot2, their documentation website http://docs.ggplot2.org/current/ is a good place to start. "],
["boxplots.html", "6.1 Boxplots", " 6.1 Boxplots The boxplot is a widely used plot that can summarise the distribution of data within a collection. We routinely use boxplots to show a trend within data during e.g. signal intensity of DNA microarrays or read-counts for a single gene across different experimental condition. 6.1.1 Native In this example we will prepare a boxplot for signal intensity across different arrays in our gene.atlas data set. The simplest way is to call the native boxplot() function. This produces a reasonable summary view of the data, but not one that would be suitable for publication purposes. # The native way would simply be: boxplot(log2(gene.atlas[sample(nrow(gene.atlas), 1000), seq(15)])) # This generates a boxplot of 1000 gene expression values for the first # 15 samples. Remember, gene.atlas contains over 22,000 expression values # and 158 samples 6.1.2 ggplot2::geom_boxplot() Using ggplot2 we can produce a much more attractive plot, although doing so is considerably more complicated. # Using ggplot, we first need to load the required libraries library(ggplot2) library(reshape2) # Once again, get 1000 values for 15 samples atlas.subset &lt;- as.data.frame(t(log2(gene.atlas[sample(nrow(gene.atlas), 1000), seq(15)]))) # We now need to transform the data from &#39;wide&#39; to &#39;long&#39; format # Your instructor will explain this process atlas.subset &lt;- cbind(atlas.subset,Group=as.factor(paste0(&quot;Group&quot;,rep(seq(3), 5))), Sample=rownames(atlas.subset)) atlas.melt &lt;- melt(atlas.subset, id.vars=c(&quot;Group&quot;, &quot;Sample&quot;), variable.name=&quot;Gene&quot;, value.name=&quot;Signal&quot;) # Now that the data is in the correct format, we can draw the graph # Again, the instructor will explain what is happening here # The &#39;+&#39; symbols are required, and tell R that the command is not finished p &lt;- ggplot(atlas.melt, aes(factor(Sample), Signal, fill=Group)) + geom_boxplot() + labs(title=&quot;boxplot summarising signal intensity&quot;, x=&quot;array&quot;, y=&quot;log2 signal&quot;) + theme(axis.text.x=element_text(angle=90)) print(p) "],
["histograms.html", "6.2 Histograms", " 6.2 Histograms A histogram shows the distribution of data for typically a single sample. 6.2.1 Native Let’s use the same data that we used in the boxplot example but concentrating on the signal intensity for the first sample only. # The base graphics way # Create a data frame slice containing our target expression data channel.data &lt;- data.frame(Signal=log2(gene.atlas[sample(nrow(gene.atlas),1000),1])) # hist() is the built-in histogram function # [, 1] selects the first (and in this case, only) column of data from channel.data hist(channel.data[, 1]) 6.2.2 ggplot2 - geom_histogram() # Now with ggplot2. The data is already in long format, so no need to &#39;melt&#39; # this time. Also ggplot2 is already loaded, so no need to do that again. p &lt;- ggplot(channel.data, aes(x=Signal)) + geom_histogram(binwidth=0.2) + labs(title=&quot;Histogram summarising signal intensity for sample 1&quot;) print(p) See also plot(density()) for a more continuous view of the data distribution. "],
["bar-charts.html", "6.3 Bar charts", " 6.3 Bar charts A barchart is superficially similar to a histogram in the bars of data are displayed. Bar charts are ideal for displaying counts associated with categorical data. 6.3.1 Native The example chart here simply presents the number of diamonds in a database of diamonds that have bheen assigned to particular classes of cut. The diamonds data comes from one of the many datasets built into R that you can use for testing and experimentation. For a full list of these, use library(help=&quot;datasets&quot;). # Let&#39;s start by having a look at the data head(diamonds) ## # A tibble: 6 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 str(diamonds) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 53940 obs. of 10 variables: ## $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... # Barplot using base version of barplot, grouping by the &#39;cut&#39; category barplot(table(diamonds[,&quot;cut&quot;])) 6.3.2 ggplot2::geom_bar() # The ggplot version in this case can be quite simple. This is thanks to the # data again being in long format, so not needing melting p &lt;- ggplot(diamonds, aes(cut)) + geom_bar() print(p) # Similarly, group by &#39;color&#39; (and appropriately enough, let&#39;s colour it in # this time) p &lt;- ggplot(diamonds, aes(color, fill = color)) + geom_bar() print(p) "],
["scatterplots.html", "6.4 Scatterplots", " 6.4 Scatterplots Scatterplots are widely used for plotting data where an object has mutiple variables. 6.4.1 Native The iris dataset, another built-in dataset in R, describes three varieties of the iris flower and a number of attributes that include the sepal and petal lengths and widths. In this case we are going to plot sepal length against width for three species of iris. head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # Base graphics. But there is no easy way with this to distinguish the # three species, so the data is pretty much useless plot(iris[,&quot;Sepal.Length&quot;], iris[,&quot;Sepal.Width&quot;]) 6.4.2 ggplot2::geom_point() # With ggplot, we can specify that we want to colour the points by Species p &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point(aes(color = Species), size=3) print(p) Now the variation in sepal shape between the species is clear Plotting with R Work your way through the previous code examples to draw boxplots, histograms, bar charts and scatter plots as described. In each case, the built-in plot function is described first, then the ggplot2 version. "],
["venn-diagrams.html", "6.5 Venn Diagrams", " 6.5 Venn Diagrams The Venn diagram is a useful plot for describing sets of information and can reflect the intersections of data. There are a number of packages that can be used for preparing Venn diagrams. I would recommend the ”Vennerable” package which can be downloaded from R-forge. This is not quite as comprehensive or complete in functionality compared to other packages but it the easiest to use and implement by a wide margin. # Vennerable is already installed on the training server, but you might need to # install it before use with another R instance # install.packages(&quot;Vennerable&quot;, repos=&quot;http://R-Forge.R-project.org&quot;) # Although it&#39;s installed, it&#39;s not loaded until we tell R to do so library(Vennerable) # Like the R base install, Vennerable comes with built-in test data, in the # form of Stem Cell information. This is not automatically available though, # so we need to load it data(StemCell) # What does StemCell contain str(StemCell) # It is a list of four character vectors, giving a list of the genes expressed # in each of four types of stem cell # Use the Venn function to count overlap between the lists Vstem &lt;- Venn(StemCell) Vstem # And plot a venn diagram of those overlaps plot(Vstem, type=&quot;ellipses&quot;, doWeights=FALSE) Venn Diagrams Draw a Venn diagram using the code above Explore the Vennerable vignette (use Google to find it online) and try designing some differently-formatted venn diagrams How many genes are expressed in all four cell types? Can you retrieve their Gene IDs from the Vstem object? -->"],
["appendix-1.html", "Appendix 1 ", " Appendix 1 "],
["summary-of-object-types.html", "Summary of Object Types", " Summary of Object Types Type Description vectors ordered collection of numeric, character, complex and logical values. factors special type vectors with grouping information of its components data frames two dimensional structures with different data types matrices two dimensional structures with data of same type arrays multidimensional arrays of vectors lists general form of vectors with different types of elements functions piece of code "],
["more-information-on-r-and-bioconductor-for-genomics.html", "More information on R and Bioconductor for Genomics", " More information on R and Bioconductor for Genomics Thomas Girke’s manuals and guides to R http://manuals.bioinformatics.ucr.edu/home http://www.r-bloggers.com/ -->"],
["appendix-2-solutions-to-exercises.html", "Appendix 2 - Solutions to exercises ", " Appendix 2 - Solutions to exercises "],
["using-vectors.html", "2.4.1 Using vectors", " 2.4.1 Using vectors mixedVector[2] returns the name and value of the second element of the vector. mixedVector[[2]] just returns the value mixedVector[[&#39;meaningOfLife&#39;]] "],
["using-lists.html", "2.4.3 Using lists", " 2.4.3 Using lists # Retrieve second and fourth elements mixedList[c(2,4)] # Retrive everything BUT 2nd and 4th elements mixedList[c(-2,-4)] names &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;) sex &lt;- c(TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE) age &lt;- c(1,2,3,4,5,6,7,8,9,10) subjects &lt;- list(names=names, sex=sex, age=age) "],
["adding-factor-values.html", "2.4.4 Adding factor values", " 2.4.4 Adding factor values levels(mandm) &lt;- c(levels(mandm), &quot;brown&quot;) # Change vector values 100 to 200 to brown mandm[100:200] = &#39;brown&#39; "],
["creating-a-data-frame.html", "2.4.6 Creating a data frame", " 2.4.6 Creating a data frame subject.data &lt;- as.data.frame(subjects) colnames(subject.data) # If they need naming colnames(subject.data) &lt;- c(&#39;names&#39;,&#39;sex&#39;,&#39;age&#39;) "],
["reading-in-the-geneatlas-data.html", "4.2 Reading in the GeneAtlas data", " 4.2 Reading in the GeneAtlas data # note the the comment/metadata delimiter is the ! symbol # the column values are separated by tabs # the column names are included in the first row - we can import Header head(read.table(gene.atlas.file, comment.char=&quot;!&quot; sep=&quot;\\t&quot;, header=TRUE)) gene.atlas &lt;- read.table(gene.atlas.file, comment.char=&quot;!&quot;, sep=&quot;\\t&quot;, header=TRUE) # read the data again, this time set the row.names with the first data column gene.atlas &lt;- read.table(gene.atlas.file, comment.char=&quot;!&quot;, sep=&quot;\\t&quot;, header=TRUE, row.names=1) "],
["creating-and-using-functions.html", "5.1 Creating and using functions", " 5.1 Creating and using functions # A function to multiply or divide multiplyFunction &lt;- function(a, b=2, multiply=TRUE) { if (multiply) { a*b } else { a/b } } # A function to return a letter at a certain position letterFunction &lt;- function(word, position) { substr(word, position, position) } # A function to generate a filled matrix makeMatrix &lt;- function (rows, columns, numbers = TRUE) { if (numbers) { matrix(seq(rows*columns), nrow = rows, ncol = columns) } else { matrix(LETTERS[1:(rows*columns)], nrow = rows, ncol = columns) } } "],
["loops-and-vectorisation.html", "5.2 Loops and vectorisation", " 5.2 Loops and vectorisation # Count down from 100 in 2s i &lt;- 100 while (i &gt;= 0) { print(i) i&lt;&lt;-i-2 } # Square of the numbers from 1 to 20 startVec &lt;- seq(20) squareVec &lt;- startVec^2 "],
["venn-diagram.html", "6.5 Venn diagram", " 6.5 Venn diagram str(Vstem) Vstem@IntersectionSets$&quot;1111&quot; -->"],
["appendix-3-the-sessioninfo-for-this-version-of.html", "Appendix 3 - The SessionInfo for this version of", " Appendix 3 - The SessionInfo for this version of sessionInfo() ## R version 3.3.0 (2016-05-03) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 10240) ## ## locale: ## [1] LC_COLLATE=English_Australia.1252 LC_CTYPE=English_Australia.1252 ## [3] LC_MONETARY=English_Australia.1252 LC_NUMERIC=C ## [5] LC_TIME=English_Australia.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] reshape2_1.4.1 ggplot2_2.1.0 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_0.12.5 rstudioapi_0.6 knitr_1.14 ## [4] magrittr_1.5 munsell_0.4.3 colorspace_1.2-6 ## [7] xtable_1.8-2 R6_2.1.3 plyr_1.8.3 ## [10] stringr_1.0.0 tools_3.3.0 grid_3.3.0 ## [13] gtable_0.2.0 miniUI_0.1.1 htmltools_0.3.5 ## [16] yaml_2.1.13 assertthat_0.1 digest_0.6.9 ## [19] tibble_1.1 bookdown_0.1.5 shiny_0.13.2 ## [22] formatR_1.4 evaluate_0.9 mime_0.4 ## [25] rmarkdown_1.0.9008 labeling_0.3 stringi_1.1.1 ## [28] scales_0.4.0 httpuv_1.3.3 "]
]
